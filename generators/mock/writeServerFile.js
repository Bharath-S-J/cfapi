import path from 'node:path';
import fs from 'node:fs/promises';
import { safeWrite } from '../../utils/fileUtils.js';
import logger from '../../utils/logger.js';
import pluralize from 'pluralize';

const importRegex = /import\s+(\w+)\s+from\s+['"]\.\/routes\/(\w+)\.routes\.js['"]/gi;
const useRegex = /app\.use\(\s*['"]\/api\/(\w+)['"]\s*,\s*(\w+)\s*\);/gi;

const generateStartupLogger = (apiPrefix) => {
  return `
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log('\\n cfapi-generated API is now running!\\n');
  console.log(\` Environment     : \${process.env.NODE_ENV || 'development'}\`);
  console.log(\` Base URL        : http://localhost:\${PORT}${apiPrefix}\`);
  console.log(\` Swagger Docs    : http://localhost:\${PORT}/api-docs\`);
  console.log('\\n  Generated by cfapi CLI tool');
});`.trim();
};

const writeServerFile = async (models, outputDir, includeStartup = false) => {
  const filePath = path.join(outputDir, 'server.js');
  const API_PREFIX = '/api';

  let existingContent = '';
  try {
    existingContent = await fs.readFile(filePath, 'utf-8');
  } catch {
    existingContent = '';
  }

  const existingImports = new Map();
  const existingUses = new Set();

  let match;
  while ((match = importRegex.exec(existingContent)) !== null) {
    const modelName = match[2].toLowerCase();
    const importVar = match[1];
    existingImports.set(modelName, importVar);
  }

  while ((match = useRegex.exec(existingContent)) !== null) {
    const routePath = match[1].toLowerCase();
    existingUses.add(routePath);
  }

  const newImportLines = [];
  const newUseLines = [];

  for (const model of models) {
    const lower = model.toLowerCase();
    const routePath = pluralize(lower);;
    const routeVar = `${lower}Routes`;

    if (!existingImports.has(lower)) {
      newImportLines.push(`import ${routeVar} from './routes/${model}.routes.js';`);
      existingImports.set(lower, routeVar);
    }

    if (!existingUses.has(routePath)) {
      newUseLines.push(`app.use('${API_PREFIX}/${routePath}', ${routeVar});`);
      existingUses.add(routePath);
    }
  }

  const dynamicOpenApiLoader = `
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
let openApiDocument = {};
try {
  openApiDocument = require('./openapi.json');
} catch (e) {
  console.error("Failed to load OpenAPI document:", e.message);
}`.trim();

  // === CASE: CREATE NEW FILE ===
  if (!existingContent) {
    const baseContent = `import express from 'express';
import dotenv from 'dotenv';
import swaggerUi from 'swagger-ui-express';
import cors from 'cors';
${newImportLines.join('\n')}

${dynamicOpenApiLoader}

dotenv.config();
const app = express();
app.use(cors());
app.use(express.json());
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(openApiDocument));

${newUseLines.join('\n')}

app.get('/', (req, res) => {
  res.send('cfapi-generated API is running');
});

${includeStartup ? generateStartupLogger(API_PREFIX) : ''}
`;

    await safeWrite(filePath, baseContent, 'server.js');
    logger.info('Created new mock server.js with initial routes');
    return;
  }

  // === CASE: UPDATE EXISTING FILE ===

  // Remove old static OpenAPI import
  existingContent = existingContent.replace(
    /import\s+openApiDocument\s+from\s+['"]\.\/openapi\.json['"].*?;\s*/g,
    ''
  );

  // Remove old startup logger
  existingContent = existingContent.replace(
    /const\s+PORT\s*=\s*process\.env\.PORT\s*\|\|\s*3000;[\s\S]+?app\.listen\([^}]+\}\);?/gs,
    ''
  );

  // Inject dynamic OpenAPI loader if not present
  if (!existingContent.includes('openApiDocument =')) {
    const dotenvIndex = existingContent.indexOf('dotenv.config();');
    if (dotenvIndex !== -1) {
      const before = existingContent.slice(0, dotenvIndex);
      const after = existingContent.slice(dotenvIndex);
      existingContent = `${before}${dynamicOpenApiLoader}\n\n${after}`;
    }
  }

  // Inject new imports
  const importMatches = [...existingContent.matchAll(/import .+ from .+;/g)];
  const lastImportEnd = importMatches.length
    ? importMatches.at(-1).index + importMatches.at(-1)[0].length
    : 0;

  const beforeImports = existingContent.slice(0, lastImportEnd);
  const afterImports = existingContent.slice(lastImportEnd);
  const importsToInsert = newImportLines.length ? '\n' + newImportLines.join('\n') + '\n' : '';
  let updatedContent = beforeImports + importsToInsert + afterImports;

  // Inject new app.use() 
  const appUseMatches = [...updatedContent.matchAll(/app\.use\([^)]+\);/g)];
  const lastAppUseMatch = appUseMatches.length ? appUseMatches.at(-1) : null;
  const insertUseIndex = lastAppUseMatch
    ? updatedContent.indexOf(lastAppUseMatch[0]) + lastAppUseMatch[0].length
    : updatedContent.indexOf('app.use(express.json());') + 'app.use(express.json());'.length;

  const usesToInsert = newUseLines.length ? '\n' + newUseLines.join('\n') + '\n' : '';
  updatedContent =
    updatedContent.slice(0, insertUseIndex) +
    usesToInsert +
    updatedContent.slice(insertUseIndex);

  // Inject startup logger 
  if (includeStartup && !updatedContent.includes('app.listen(')) {
    updatedContent += `\n\n${generateStartupLogger(API_PREFIX)}\n`;
  }

  await safeWrite(filePath, updatedContent, 'server.js');
  logger.info('Updated mock server.js with new models');
};

export default writeServerFile;
